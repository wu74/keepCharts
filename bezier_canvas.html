<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #container {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="graph" width="400" height="400"></canvas>
  </div>

  <script>
    const container = document.querySelector('#container')
    const c = container.querySelector('#graph')
    const ctx = c.getContext('2d')

    let curDom = null
    let hitc = null
    let hitctx = null
    let colorMapping = {}
    createHitCanvas()
    // 有了影子画布

    // 画坐标系 和 控制点
    drawAxis()
    renderControlPoint(50, 50, 'point1')
    renderControlPoint(250, 250, 'point2')
    drawBezier()

    // 鼠标移入容器后  判断按下的点是否在控制点内  如果在 并且 进行了拖拽行为
    // 就不停清空画布 然后再重新绘制

    container.addEventListener('mousedown', (e) => {
      console.log(e, '鼠标按下');
      // 按下的时候判断是不是点在 控制点上
      let activeDom = isClickInPoint(e)
      curDom = activeDom
      // console.log(curDom, 'iscLICK')
      // container.addEventListener('mousemove', mousemoveFn)

      if (activeDom) {
        container.addEventListener('mousemove', mousemoveFn)
      }
    })
    container.addEventListener('mouseup', function (e) {
      console.log('鼠标抬起-----------');
      container.removeEventListener('mousemove', mousemoveFn)
    })

    function mousemoveFn(e) {
      console.log(e, '鼠标移动');

      const rect = c.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // 不停的清空画布 和影子画布 然后在各自的画布上重新绘制
      ctx.clearRect(0, 0, 400, 400)
      hitctx.clearRect(0, 0, 400, 400)

      drawAxis()

      if (curDom === 'point1') {
        renderControlPoint(x, y, 'point1')
        renderControlPoint(250, 250, 'point2')
      } else {
        renderControlPoint(x, y, 'point2')
        renderControlPoint(50, 50, 'point1')
      }
      drawBezier(x, y, 250, 250, curDom)
      // renderControlPoint(400 - e.pageX, 400 - e.pageY, 'point2')
    }

    function createHitCanvas() {
      const shadow = document.createElement('canvas')
      shadow.width = c.clientWidth
      shadow.height = c.clientHeight

      hitc = shadow
      hitctx = shadow.getContext('2d')

      // shadow.style.display = 'none'
      container.appendChild(hitc)
    }


    function rgbToHex(color) {
      const arr = color.match(/(\d(\.\d+)?)+/g) || [];
      const res = arr.map(s => parseInt(s, 10))

      const { r, g, b } = {
        r: res[0],
        g: res[1],
        b: res[2]
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`

      function toHex(n) {
        return `${n > 15 ? '' : 0}${n.toString(16)}`
      }
    }

    function isClickInPoint(e) {
      const rect = c.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;


      const point = {
        x,
        y,
      }

      console.log(point, 'point'); // 打印点击位置坐标

      // 拿当前坐标去影子画布上 取元素
      let imageData = hitctx.getImageData(x, y, 1, 1).data

      if (imageData[3] == 255) {
        let colorKey = rgbToHex(`rgb(${imageData[0]}, ${imageData[1]}, ${imageData[2]})`);
        
        // 获取到了当前点击的是哪个元素
        return colorMapping[colorKey]
      }
    }

    function drawAxis() {
      ctx.beginPath()
      ctx.strokeStyle = '#8d8d8d'
      ctx.lineWidth = 2
      ctx.moveTo(0, 0)
      ctx.lineTo(0, 400)
      ctx.stroke()
      ctx.closePath()

      ctx.beginPath()
      ctx.strokeStyle = '#8d8d8d'
      ctx.lineWidth = 2
      ctx.moveTo(0, 400)
      ctx.lineTo(400, 400)
      ctx.stroke()
      ctx.closePath()

      ctx.beginPath()
      ctx.lineWidth = 5
      ctx.strokeStyle = '#e5e5e5'
      ctx.moveTo(0, 400)
      ctx.lineTo(400, 0)
      ctx.stroke()
      ctx.closePath()
    }


    function renderControlPoint(x = 50, y = 50, curDom = 'point1') {
      // 在显示画布上画元素
      ctx.beginPath()
      ctx.lineWidth = 1
      ctx.strokeStyle = '#333'
      ctx.arc(x, y, 10, 0, 2 * Math.PI)
      ctx.stroke()
      ctx.closePath()

      // 先获取颜色  然后跟类名一起存入 映射表
      let color = getRandomColor()
      colorMapping[color] = curDom

      // 在影子画布上同样的位置画同样的元素, 用当前颜色填充
      hitctx.beginPath()
      hitctx.lineWidth = 1
      hitctx.strokeStyle = '#333'
      hitctx.arc(x, y, 10, 0, 2 * Math.PI)
      hitctx.stroke()
      hitctx.fillStyle = color
      hitctx.fill()
      hitctx.closePath()

      function getRandomColor() {
        return '#' + (function (h) {
          return new Array(7 - h.length).join('0') + h
        })((Math.random() * 0x1000000 << 0).toString(16))
      }
    }


    function drawBezier(x1 = 50, y1 = 50, x2 = 250, y2 = 250, curDom = 'point1') {
      let startPos = curDom === 'point1' ? [0, 400] : [400, 0]
      let endPos = curDom === 'point1' ? [400, 0] : [0, 400]

      ctx.beginPath()
      ctx.lineWidth = 4
      ctx.strokeStyle = '#000000'
      ctx.moveTo(...startPos)
      ctx.bezierCurveTo(x1, y1, x2, y2, ...endPos)
      ctx.stroke()
    }
  </script>
</body>

</html>