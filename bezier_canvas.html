<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #container {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="graph" width="400" height="400"></canvas>
  </div>

  <script>
    const container = document.querySelector('#container')
    const c = container.querySelector('#graph')
    const ctx = c.getContext('2d', { willReadFrequently: true })

    let curDom = null
    let copyCtx = null
    let colorMapping = {}
    let point1Pos = {
      x: 50,
      y: 50
    }
    let point2Pos = {
      x: 250,
      y: 250
    } 
    // 创建副本画布
    createHitCanvas()

    // 画坐标系 和 控制点
    drawAxis()
    drawControlLine()

    renderControlPoint(50, 50, 'point1')
    renderControlPoint(250, 250, 'point2')
    drawBezier()

    // 鼠标移入容器后  判断按下的点是否在控制点内  如果在 并且 进行了拖拽行为
    // 就不停清空画布 然后再重新绘制

    container.addEventListener('mousedown', (e) => {
      // 按下的时候判断是不是点在 控制点上
      let activeDom = isClickInPoint(e)
      curDom = activeDom

      if (activeDom) {
        container.addEventListener('mousemove', mousemoveFn)
      }
    })
    container.addEventListener('mouseup', function (e) {
      container.removeEventListener('mousemove', mousemoveFn)
    })

    function mousemoveFn(e) {
      // 算出当前移动的点 在 canvas 画布上的坐标
      const rect = c.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // 不停的清空画布 和影子画布 然后在各自的画布上重新绘制
      ctx.clearRect(0, 0, 400, 400)
      copyCtx.clearRect(0, 0, 400, 400)

      drawAxis()
      drawControlLine()
      if (curDom === 'point1') {
        point1Pos = { x, y }
        renderControlPoint(x, y, 'point1')
        renderControlPoint(point2Pos.x, point2Pos.y, 'point2')
      } else {
        point2Pos = { x, y }
        renderControlPoint(x, y, 'point2')
        renderControlPoint(point1Pos.x, point1Pos.y, 'point1')
      }

      let anotherDom = curDom === 'point1' ? 'point2' : 'point1'

      let ax = curDom === 'point1' ? point2Pos.x : point1Pos.x
      let ay = curDom === 'point1' ? point2Pos.y : point1Pos.y
      // console.log(curDom, 'curDom');

      drawBezier(x, y, ax, ay, curDom)
    }

    function createHitCanvas() {
      const shadow = document.createElement('canvas')
      shadow.width = c.clientWidth
      shadow.height = c.clientHeight

      copyCtx = shadow.getContext('2d',  { willReadFrequently: true })

      shadow.style.display = 'none'
      container.appendChild(shadow)
    }


    function rgbToHex(color) {
      const arr = color.match(/(\d(\.\d+)?)+/g) || [];
      const res = arr.map(s => parseInt(s, 10))

      const { r, g, b } = {
        r: res[0],
        g: res[1],
        b: res[2] 

      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`

      function toHex(n) {
        return `${n > 15 ? '' : 0}${n.toString(16)}`
      }
    }

    function isClickInPoint(e) {
      const rect = c.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // 拿当前坐标去影子画布上 取元素
      let imageData = copyCtx.getImageData(x, y, 1, 1).data

      if (imageData[3] == 255) {
        let colorKey = rgbToHex(`rgb(${imageData[0]}, ${imageData[1]}, ${imageData[2]})`);
        
        // 获取到了当前点击的是哪个元素
        return colorMapping[colorKey]
      }
    }

    function drawAxis() {
      ctx.beginPath()
      ctx.strokeStyle = '#8d8d8d'
      ctx.lineWidth = 2
      ctx.moveTo(0, 0)
      ctx.lineTo(0, 400)
      ctx.stroke()
      ctx.closePath()

      ctx.beginPath()
      ctx.strokeStyle = '#8d8d8d'
      ctx.lineWidth = 2
      ctx.moveTo(0, 400)
      ctx.lineTo(400, 400)
      ctx.stroke()
      ctx.closePath()

      ctx.beginPath()
      ctx.lineWidth = 5
      ctx.strokeStyle = '#e5e5e5'
      ctx.moveTo(0, 400)
      ctx.lineTo(400, 0)
      ctx.stroke()
      ctx.closePath()
    }


    function renderControlPoint(x = 50, y = 50, curDom = 'point1') {
      // 在显示画布上画元素
      ctx.beginPath()
      ctx.lineWidth = 1
      ctx.strokeStyle = '#333'
      ctx.arc(x, y, 10, 0, 2 * Math.PI)
      ctx.fillStyle = '#fff'
      ctx.fill()
      ctx.stroke()
      ctx.closePath()

      // 先获取颜色  然后跟类名一起存入 映射表
      let color = getRandomColor()
      colorMapping[color] = curDom

      // 在影子画布上同样的位置画同样的元素, 用当前颜色填充
      copyCtx.beginPath()
      copyCtx.lineWidth = 1
      copyCtx.strokeStyle = '#333'
      copyCtx.arc(x, y, 10, 0, 2 * Math.PI)
      copyCtx.stroke()
      copyCtx.fillStyle = color
      copyCtx.fill()
      copyCtx.closePath()

      function getRandomColor() {
        return '#' + (function (h) {
          return new Array(7 - h.length).join('0') + h
        })((Math.random() * 0x1000000 << 0).toString(16))
      }
    }


    function drawBezier(x1 = 50, y1 = 50, x2 = 250, y2 = 250, curDom = 'point1') {
      let startPos = curDom === 'point1' ? [0, 400] : [400, 0]
      let endPos = curDom === 'point1' ? [400, 0] : [0, 400]

      ctx.beginPath()
      ctx.lineWidth = 4
      ctx.strokeStyle = '#000000'
      ctx.moveTo(...startPos)
      ctx.bezierCurveTo(x1, y1, x2, y2, ...endPos)
      ctx.stroke()
    }


    function drawControlLine() {
      ctx.beginPath()
      ctx.lineWidth = 2
      ctx.strokeStyle = '#696969'
      ctx.moveTo(0, 400)
      ctx.lineTo(point1Pos.x, point1Pos.y)
      ctx.stroke()
      ctx.closePath()

      ctx.beginPath()
      ctx.lineWidth = 2
      ctx.strokeStyle = '#696969'
      ctx.moveTo(400, 0)
      ctx.lineTo(point2Pos.x, point2Pos.y)
      ctx.stroke()
      ctx.closePath()
    }
  </script>
</body>

</html>